# Graph

## 1 图的DFS 6/10

需要明确：
1 递归终止条件是什么？
2 是否需要回溯，以及如何实现标记节点？

|序号|难度|题目|
|:----|:----|-----|
|[133](/leetcode/LC133I.java)|中等|克隆图|
|[200](/leetcode/LC200I.java)|中等|岛屿数量|
|[130](/leetcode/LC130.java)|中等|被围绕的区域|
|[329](/leetcode/LC329.java)|困难|矩阵中的最长递增路径|
|[329](/leetcode/LC529.java)|中等|扫雷游戏|
|[827](/leetcode/LC827.java)|困难|最大人工岛|

## 2 图的BFS 6/10

与DFS不同的是，要先判断下一层节点是否合规，合规的话标记visited并添加进队列。

|序号|难度|题目|
|:----|:----|-----|
|[133](/leetcode/LC133I.java)|中等|克隆图|
|[200](/leetcode/LC200II.java)|中等|岛屿数量|
|[417](/leetcode/LC417II.java)|中等|太平洋大西洋水流问题|
|[542](/leetcode/LC542.java)|中等|01矩阵|
|[127](/leetcode/LC127.java)|中等|单词接龙|

## 2.1 Dijkstra

1. 构建邻接矩阵，无边表示为权重-1.
2. 初始化 距离 数组，所有点到源点的初始距离都为无穷大，源点的距离为0。
3. 取出当前 距离 最小的点，加入结果集，对它的后驱节点进行松弛操作。
4. 直到所有点都遍历过（即结果集=图的点集），结束。


|序号|难度|题目|
|:----|:----|-----|
|[743](/leetcode/LC743.java)|中等|网络延迟时间|

## 3 拓扑排序 2/5

### 3.1 入度表（BFS）实现

#### 3.1.1 判断是否有环

1. 统计课程安排图中每个节点的入度，生成 入度表 indegrees。
2. 借助一个队列 queue，将所有入度为 0 的节点入队。
3. 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
    - 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 -1，即 indegrees[cur] -= 1。
    - 当入度 -1 后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
4. 在每次 pre 出队时，执行 numCourses--；
    - 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。
    - 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。
    
#### 3.1.2 实现拓扑排序

在判断的过程中即可实现拓扑排序
    
|序号|难度|题目|
|:----|:----|-----|
|[207](/leetcode/LC207I.java)|中等|课程表|
|[210](/leetcode/LC210I.java)|中等|课程表II|

### 3.2 DFS实现

#### 3.2.1 判断是否有环

有back edge 说明有环。
DFS -> 发现back edge -> return false -> 发现false，break

#### 3.2.2 实现拓扑排序

返回的时候将节点入栈。DFS遍历完毕以后，以出栈书顺序返回节点，即为拓扑排序。


|序号|难度|题目|
|:----|:----|-----|
|[207](/leetcode/LC207II.java)|中等|课程表|