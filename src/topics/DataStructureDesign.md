# Data Structure Design

## 1 [LRU](/leetcode/LC146.java)

### 1.1 目标
设计和实现LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
1. 获取数据 get(key)
   - 如果关键字 (key) 不存在于缓存中，返回-1。
   - 否则则获取关键字的值（总是正数），**此操作会更新该关键字的使用时间**。

2. 写入数据 put(key, value) 
   - 如果关键字已经存在，则变更其数据值，**此操作会更新该关键字的使用时间**。
   - 如果关键字不存在，则插入该组「关键字/值」，**此操作会更新该关键字的使用时间**。
   - 当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

### 1.2 要求
O(1)时间复杂度。

### 1.3 思路

#### 1.3.1 所需数据结构

Node<Key, Value> 维护关键字与关键字的值

HashMap<Key, Node> map存放关键字与其对应的信息节点，其容量为缓存容量。

LinkedList\<Node> list存放关键字对应的信息节点的使用顺序。（直接用头尾节点代替链表）

#### 1.3.2 执行机制

1. 获取数据：

   - 在map里寻找关键字，如不存在返回-1.

   - 如果存在，返回关键字对应的值，通过map找到对应的信息节点，将该信息节点移动到list的头部。

2. 写入数据：

   - 在map里寻找关键字，如果存在，找到对应的信息节点，更新信息节点中的信息，并将信息节点移动到

   - 未达到容量上限时，往map里存放键值对，往list头部加入信息节点。
   - 达到容量上限时，删除list尾部的信息节点，删除map里对应的键值对。将新的信息节点加入list头部，往map里存放键值对。

## 2 [LFU](/leetcode/LC460.java)

### 2.1 目标
请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。

get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。
「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

2. 写入数据 put(key, value) 
   - 如果关键字已经存在，则变更其数据值，**此操作会更新该关键字的使用时间**。
   - 如果关键字不存在，则插入该组「关键字/值」，**此操作会更新该关键字的使用时间**。
   - 当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

### 2.2 要求
O(1)时间复杂度。

### 2.3 思路

#### 2.3.1 所需数据结构

Node<Key, Value> 维护关键字与关键字的值

HashMap<Key, Node> map存放关键字与其对应的信息节点，其容量为缓存容量。

LinkedList\<Node> list存放关键字对应的信息节点的使用顺序。

#### 2.3.2 执行机制

1. 获取数据：

   - 在map里寻找关键字，如不存在返回-1.

   - 如果存在，返回关键字对应的值，通过map找到对应的信息节点，将该信息节点移动到list的头部。

2. 写入数据：

   - 在map里寻找关键字，如果存在，找到对应的信息节点，更新信息节点中的信息，并将信息节点移动到

   - 未达到容量上限时，往map里存放键值对，往list头部加入信息节点。
   - 达到容量上限时，删除list尾部的信息节点，删除map里对应的键值对。将新的信息节点加入list头部，往map里存放键值对。

